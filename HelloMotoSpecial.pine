//@version=5
indicator("ZONE SCALPING + SIDEWAY + TRENDING + 3BR (combo) ", overlay = true)


// Variables to store the highs and lows of 9:15 and 9:20 candles
var float p_open_915 = na
var float p_close_915 = na
var float p_high_920 = na
var float p_low_920 = na
var float newRangeValueLower = na
var float newRangeValueUpper = na
var float newRangeValueMid = na
// var float indexOfBar = na


// Flags to track buy and sell signals and daily signal status
// var bool buy_signal = false
// var bool sell_signal = false
// var bool signal_triggered = false  // Tracks if signal has already been given for the day

// Define the time zone for India (GMT+5:30)
indian_time = timestamp("Asia/Kolkata", year, month, dayofmonth, hour, minute)

// Reset signal tracking at the start of a new day
if (dayofmonth != dayofmonth[1])
    p_open_915 := na
    p_close_915 := na
    // buy_signal := false
    // sell_signal := false
    // signal_triggered := false

// Capture 9:15 candle data
if (hour(indian_time) == 9 and minute(indian_time) == 15)
    p_open_915 := open
    p_close_915 := close
    // buy_signal := false
    // sell_signal := false
    // signal_triggered := false
    // indexOfBar := bar_index

if (hour(indian_time) == 9 and minute(indian_time) == 20)
    p_high_920 := high
    p_low_920 := low


if (hour(indian_time) == 15)
    p_open_915 := na
    p_close_915 := na
    newRangeValueLower := na
    newRangeValueUpper := na
    p_high_920 := na
    p_low_920 := na


rangeValue = math.abs(p_open_915-p_close_915)


if (p_open_915 > p_close_915)
    newRangeValueUpper := p_open_915 + rangeValue
    newRangeValueLower := p_close_915 - rangeValue

if (p_open_915 < p_close_915)
    newRangeValueUpper := p_open_915 - rangeValue
    newRangeValueLower := p_close_915 + rangeValue


plot(newRangeValueUpper,  style = plot.style_cross,color=color.rgb(0, 255, 0), title="9:15 Open")
plot(newRangeValueLower, style = plot.style_cross,color=color.rgb(255, 0, 0), title="9:15 Close")
plot((newRangeValueUpper + newRangeValueLower) / 2, style = plot.style_cross,color=color.rgb(0, 0, 255), title="Mid Line")

plot(p_high_920,  style = plot.style_cross,color=color.rgb(255, 0, 0), title="9:20 high")
plot(p_low_920, style = plot.style_cross,color=color.rgb(0, 255, 0), title="9:20 low")
plot(p_high_920+45,  style = plot.style_cross,color=color.rgb(255, 255, 255), title="9:20 tgt")
plot(p_low_920-45, style = plot.style_cross,color=color.rgb(255, 255, 255), title="9:20 tgt")



//===============================================================================================
//===============================================================================================

//===============================================================================================
//===============================================================================================




// Bullish and Bearish Candle pattern
stable_candle = math.abs(close-open) / ta.tr > 0.5

rsi_value = ta.rsi(close, 14)
rsi_below_50 = rsi_value < 50
rsi_above_50 = rsi_value > 50

bullish_engulfing = (close[1] < open[1]) and (close > open) and (close > open[1]) //and (open < close[1])
bearish_engulfing = (close[1] > open[1]) and (close < open) and (close < open[1]) //and (open > close[1])

lastCloseMin5 = math.min(close[1], close[2], close[3], close[4], close[5])
lastCloseMax5 = math.max(close[1], close[2], close[3], close[4], close[5])
decClose = close < close[5]
incClose = close > close[5]


a = 10
b = 3
ob = 50
os = -50
// Range Calculation
ll = ta.lowest(low, a)
hh = ta.highest(high, a)
diff = hh - ll
rdiff = close - (hh + ll) / 2

avgrel = ta.ema(ta.ema(rdiff, b), b)
avgdiff = ta.ema(ta.ema(diff, b), b)
// SMI calculations
SMI = avgdiff != 0 ? avgrel / (avgdiff / 2) * 100 : 0
SMIsignal = ta.ema(SMI, b)
emasignal = ta.ema(SMI, 4)

krypton_fear_greed_buy_filter =  SMIsignal < -47
krypton_fear_greed_sell_filter =  SMIsignal > 47


buy = stable_candle and bullish_engulfing and rsi_below_50 and decClose    //  decClose   //   close > lastCloseMin5 //
sell = stable_candle and bearish_engulfing and rsi_above_50 and incClose  //  incClose   //   close < lastCloseMax5 // 
buy_krypton = buy and krypton_fear_greed_buy_filter
sell_krypton = sell and krypton_fear_greed_sell_filter

plotshape(buy, title="REVERSAL BUYING", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)
plotshape(sell, title="REVERSAL SELLING", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)

plotshape(buy_krypton, title="STRONG REVERSAL BUYING", location=location.belowbar, color=#00ff08, style=shape.triangleup, size=size.small)
plotshape(sell_krypton, title="STRONG REVERSAL SELLING", location=location.abovebar, color=#fc0000, style=shape.triangledown, size=size.small)
// plotshape(stable_candle, title="Stable Candle", location=location.abovebar, color=color.yellow, style=shape.xcross, size=size.tiny)


// VWAP PLOTTING

vwapValue = ta.vwap(hlc3)

plot(vwapValue, title="VWAP", color=#2962FF)


// 10 EMA STRATEGY

ema10 = ta.ema(close, 10)

plot(ema10, color = #00ff08, title = "EMA 10")

slope_ema10 = (ema10 - ema10[1]) / 2
angle = math.atan(slope_ema10) * (180 / math.pi)

// plot(slope_ema10, color = #ff0000, title = "slope_ema10 ")
// plot(angle, color = #ff0000, title = "angle 10")


redCandle = close[1] < open[1] and low[1] > ema10[1]
greenCandle = close[1] > open[1] and high[1] < ema10[1]


// SUPERTREND

Periods = 9   // atr length 
Multiplier = 2  // factor
atr2 = ta.sma(ta.tr, Periods)
atr = ta.atr(Periods)

STsrc = hl2 

up = STsrc - (Multiplier * atr)
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up

dn = STsrc + (Multiplier * atr)
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn

trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend


upPlot = plot(trend == 1 ? up : na, title="Up Super Trend", style=plot.style_linebr, linewidth=2, color=color.green)
dnPlot = plot(trend == 1 ? na : dn, title="Down Super Trend", style=plot.style_linebr, linewidth=2, color=color.red)



trendBuy = redCandle and high > high[1] and (angle >= 50) and trend > 0//and low > ema10
trendSell = greenCandle and low < low[1] and (angle <= -50) and trend < 0 //and high < ema10

var bool inBuyT = false
var bool inSellT = false



ema10BuySignal = trendBuy  and not inBuyT  //and rsi_value > ta.rsi(close[1], 14) 
ema10SellSignal = trendSell and not inSellT  //and rsi_value < ta.rsi(close[1], 14) 

if (ema10BuySignal)
    inBuyT := true
    inSellT := false

if (ema10SellSignal)
    inSellT := true
    inBuyT := false

if (inBuyT and low < ema10)
    inBuyT := false

if (inSellT and high > ema10)
    inSellT := false


plotshape(ema10BuySignal, title="TREND BUYING", location=location.belowbar, color=#e5ff00, style=shape.triangleup, size=size.small)
plotshape(ema10SellSignal, title="TREND SELLING", location=location.abovebar, color=#ea00ff, style=shape.triangledown, size=size.small)



sourceMACD = close

// MACD Options
macd_length_fast   = 12
macd_length_slow   = 26
macd_length_signal = 9
ema_length         = 9
// Calculate EMA
ema                = ta.ema(sourceMACD, ema_length)


// ZERO LAG
// Fast line
ma1= ta.ema(sourceMACD, macd_length_fast)
ma2 = ta.ema(ma1,macd_length_fast)
zerolagEMA = ((2 * ma1) - ma2)

// Slow line
mas1=  ta.ema(sourceMACD , macd_length_slow) 
mas2 =  ta.ema(mas1 , macd_length_slow)
zerolagslowMA = ((2 * mas1) - mas2)

// MACD line
ZeroLagMACD = zerolagEMA - zerolagslowMA 

// Signal line
emasig1 = ta.ema(ZeroLagMACD, macd_length_signal)
emasig2 = ta.ema(emasig1, macd_length_signal)
signal =  (2 * emasig1) - emasig2

hist = ZeroLagMACD - signal

upHist = (hist > 0) ? hist : 0
downHist = (hist <= 0) ? hist : 0


// Calculate Elder Impulse
elder_bulls = (ema[0] > ema[1]) and (hist[0] > hist[1])
elder_bears = (ema[0] < ema[1]) and (hist[0] < hist[1])
elder_color = elder_bulls ? #00ff08 : elder_bears ? #ff0000 : #008cff
//  Green: If Bulls Control Trend and Momentum
//  Red: If Bears Control Trend and Mementum
//  Blue: If Neither Bulls or Bears Control the Market

barcolor(elder_color)

adxlen = input(14, title="ADX Smoothing")
dilen = input(14, title="DI Length")
dirmov(len) =>
	ADXup = ta.change(high)
	ADXdown = -ta.change(low)
	plusDM = na(ADXup) ? na : (ADXup > ADXdown and ADXup > 0 ? ADXup : 0)
	minusDM = na(ADXdown) ? na : (ADXdown > ADXup and ADXdown > 0 ? ADXdown : 0)
	truerange = ta.rma(ta.tr, len)
	plus = fixnan(100 * ta.rma(plusDM, len) / truerange)
	minus = fixnan(100 * ta.rma(minusDM, len) / truerange)
	[plus, minus]
adx(dilen, adxlen) =>
	[plus, minus] = dirmov(dilen)
	sum = plus + minus
	adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)
sig = adx(dilen, adxlen)
bgcolor(sig < 17 ? color.rgb(255, 82, 82, 93) : color.rgb(76, 175, 79, 93), title="Background Color Based on ADX Signal")





// VIDYA


// ＩＮＰＵＴＳ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Input parameters for length, momentum, and source data
int   vidya_length   = input.int(10, "VIDYA Length")       // Length of the VIDYA calculation
int   vidya_momentum = input.int(20, "VIDYA Momentum")    // Momentum length for VIDYA
float band_distance  = input.float(2, "Distance factor for upper/lower bands", step = 0.1)  // Distance factor for upper/lower bands
// Define pivot parameters
int pivot_left_bars  = 3                                             // Left side pivot bars
int pivot_right_bars = pivot_left_bars                              // Right side pivot bars

float source         = input.source(close, "Source")    // Source for VIDYA calculation


// Initialize variables for line, volume, and trend state
var line pivot_line    = na      // Variable for storing line references
var float volume_value = na     // Variable for storing volume data
float smoothed_value   = na   // Smoothing variable for VIDYA trend levels
var bool is_trend_up   = na  // Boolean variable for tracking trend direction

// Initialize arrays for storing line and volume information
var array<line> liquidity_lines_low  = array.new<line>(500)    // Array for storing lines for lows
var array<line> liquidity_lines_high = array.new<line>(500)  // Array for storing lines for highs

var float up_trend_volume   = na     // Volume accumulated during uptrend
var float down_trend_volume = na  // Volume accumulated during downtrend
// }


// ＦＵＮＣＴＩＯＮＳ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{

// Define VIDYA (Variable Index Dynamic Average) function
vidya_calc(src, vidya_length, vidya_momentum) =>
    float momentum         = ta.change(src)
    float sum_pos_momentum = math.sum((momentum >= 0) ? momentum : 0.0, vidya_momentum)
    float sum_neg_momentum = math.sum((momentum >= 0) ? 0.0 : -momentum, vidya_momentum)
    float abs_cmo          = math.abs(100 * (sum_pos_momentum - sum_neg_momentum) / (sum_pos_momentum + sum_neg_momentum))
    float alpha            = 2 / (vidya_length + 1)
    var float vidya_value  = 0.0
    vidya_value           := alpha * abs_cmo / 100 * src + (1 - alpha * abs_cmo / 100) * nz(vidya_value[1])

    ta.sma(vidya_value, 15)

// Method to extend lines and add labels for liquidity levels
method extend_liquidity_lines(array<line> line_array, float price_level, bool is_cross, volume_val)=>
    if line_array.size() > 0 and last_bar_index - bar_index < 5000
        for i = 0 to line_array.size()-1 
            if i < line_array.size()
                line liquidity_line      = line_array.get(i)
                float current_line_level = line.get_y2(liquidity_line)
                bool price_cross         = is_cross 
                                  ? price_level < current_line_level and price_level[1] >= current_line_level 
                                  : price_level > current_line_level and price_level[1] <= current_line_level

                bool is_short_line = bar_index - line.get_x1(liquidity_line) < 50

                if price_cross and is_short_line
                    line.set_x2(liquidity_line, bar_index)
                    line_array.remove(i)

                    // Add volume label to the liquidity zone

                    // label.new(bar_index-1, price_level[1], 
                    //          str.tostring(volume_val, format.volume), 
                    //          color      = color.rgb(0, 0, 0, 99), 
                    //          style      = is_cross ? label.style_label_lower_left : label.style_label_upper_left,
                    //          textcolor  = chart.fg_color, 
                    //          size       = size.small)

                    // // Add a circle label to represent liquidity zone
                    // label.new(bar_index-1, price_level[1], 
                    //          text       = "◉", 
                    //          color      = #00000003, 
                    //          textcolor  = is_cross ? #dd326b : #17dfad, 
                    //          style      = label.style_label_center, 
                    //          size       = size.normal)
// }


// ＣＡＬＣＵＬＡＴＩＯＮＳ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Calculate the Average True Range (ATR)
float atr_value = ta.atr(200)  // ATR calculation with length of 200

// Calculate the VIDYA (Variable Index Dynamic Average)
vidya_value = vidya_calc(source, vidya_length, vidya_momentum)

// Calculate upper and lower bands based on VIDYA and ATR
float upper_band = vidya_value + atr_value * band_distance
float lower_band = vidya_value - atr_value * band_distance

// Detect trend direction using crossovers of source with bands
if ta.crossover(source, upper_band)
    is_trend_up := true 
if ta.crossunder(source, lower_band)
    is_trend_up := false 

// Set trend-based smoothing variable
if is_trend_up
    smoothed_value := lower_band
if not is_trend_up
    smoothed_value := upper_band
if ta.change(is_trend_up)
    smoothed_value := na

// Calculate pivot highs and lows for price action
float pivot_high = ta.pivothigh(pivot_left_bars, pivot_right_bars)
float pivot_low  = ta.pivotlow(close, pivot_left_bars, pivot_right_bars)


// Create and store lines for pivot lows (support zones)

if low[pivot_right_bars] > smoothed_value and pivot_low 
    pivot_line := line.new(
                           bar_index[pivot_right_bars], 
                           low[pivot_right_bars], 
                           bar_index[pivot_right_bars]+5, 
                           low[pivot_right_bars], 
                           color = color.new(#17dfad, 100)
                           )

    liquidity_lines_low.push(pivot_line)
    volume_value := math.sum(volume, pivot_right_bars + pivot_left_bars) / (pivot_right_bars + pivot_left_bars)

// Create and store lines for pivot highs (resistance zones)
if high[pivot_right_bars] < smoothed_value and pivot_high 
    pivot_line := line.new(
                           bar_index[pivot_right_bars], 
                           high[pivot_right_bars], 
                           bar_index[pivot_right_bars]+5, 
                           high[pivot_right_bars],
                           color = color.new(#dd326b, 100)
                           )

    liquidity_lines_high.push(pivot_line)
    volume_value := math.sum(-volume, pivot_right_bars + pivot_left_bars) / (pivot_right_bars + pivot_left_bars)

// Extend lines to track price movements
liquidity_lines_high.extend_liquidity_lines(smoothed_value, true, volume_value)
liquidity_lines_low.extend_liquidity_lines(smoothed_value, false, volume_value)

// Detect changes in the trend direction
bool trend_cross_up   = not is_trend_up[1] and is_trend_up
bool trend_cross_down = not is_trend_up and is_trend_up[1]

// Reset volume counters when trend changes
if ta.change(trend_cross_up) or ta.change(trend_cross_down)
    up_trend_volume := 0
    down_trend_volume := 0

// Accumulate volume during trends
if not(ta.change(trend_cross_up) or ta.change(trend_cross_down))
    up_trend_volume      += (close > open ? volume : 0)
    down_trend_volume    += (close < open ? volume : 0)

// Calculate average volume
float avg_volume_delta    = (up_trend_volume + down_trend_volume) / 2

// Determine the color of the trend
color trend_color = is_trend_up ? #17dfad 
                       : not is_trend_up ? #dd326b
                       : chart.fg_color

// Calculate delta volume percentage
string delta_volume = 
                   str.tostring(((up_trend_volume - down_trend_volume) / avg_volume_delta) * 100, format.percent) == "NaN%" 
                   ? "0%" 
                   : str.tostring(((up_trend_volume - down_trend_volume) / avg_volume_delta) * 100, format.percent)

// }


// ＰＬＯＴ ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――{
// Display labels for volume and trend statistics on the last bar
if barstate.islast
    label.delete(
         label.new(bar_index + 10, smoothed_value, 
         "Buy: " + str.tostring(up_trend_volume, format.volume) 
         + "\n Sell: " + str.tostring(down_trend_volume, format.volume) 
         + "\nDelta Volume: " + delta_volume, 
        //  color      = color.new(trend_color, 90),
         style      = label.style_label_left, 
         textcolor  = chart.fg_color
         )[1])
    
    // label.delete(label.new(bar_index, smoothed_value, 
    //              text       = "✪", 
    //              color      = #00000003,
    //              textcolor  = trend_color, 
    //              style      = label.style_label_center, 
    //              size       = size.large)[1])



// Plot the VIDYA trend line

// p1 = plot(smoothed_value, color = trend_color, linewidth = 2, style = plot.style_linebr)
// p2 = plot(hl2, display = display.none)


// Fill between the plot and the VIDYA line

// fill(p1, p2, smoothed_value, hl2, color.new(trend_color, shadow ? 80 : 100), na)

// Plot trend change markers (up and down arrows)

// plotshape(
//          series     = trend_cross_up[1] ? smoothed_value[0] : na, 
//          title      = "Trend Up", 
//          style      = shape.labelup, 
//          location   = location.absolute, 
//          color      = color.new(#17dfad, 50), 
//          text       = "▲", 
//          textcolor  = chart.fg_color
//          )

// plotshape(
//          series     = trend_cross_down[1] ? smoothed_value[0] : na, 
//          title      = "Trend Down", 
//          style      = shape.labeldown, 
//          location   = location.absolute, 
//          color      = color.new(#dd326b, 50), 
//          text       = "▼", 
//          textcolor  = chart.fg_color
//          )









// N BAR REVERSAL



//---------------------------------------------------------------------------------------------------------------------
// Settings 
//---------------------------------------------------------------------------------------------------------------------{

display  = display.all - display.status_line
brpType = input.string("Enhanced", "Pattern Type", options = ["Normal", "Enhanced", "All"], display = display)
brpSR  = input.string("Zone", "Derived Support and Resistance", options = ["Level", "Zone", "None"], display = display)

trendIndiGroup = 'Trend Filtering'
trendType = input.string("None", "Filtering", options = ["Moving Average Cloud", "None"], group = trendIndiGroup, inline = 'flt', display = display)
trendFilt = input.string("Aligned", "", options = ["Aligned", "Opposite"], group = trendIndiGroup, inline = 'flt', display = display) // options = ["Aligned", "Opposite", "No detection"]

ma_Group  = 'Moving Average Settings'
maType    = input.string("HMA", "Type", options = ["SMA", "EMA", "HMA", "RMA", "WMA", "VWMA"], group = ma_Group, display = display)
maFLength  = input.int(50, 'Fast Length', minval = 1, maxval = 100, group = ma_Group, display = display)
maSLength  = input.int(200, 'Slow Length', minval = 100, group = ma_Group, display = display)


//---------------------------------------------------------------------------------------------------------------------}
// Functions / Methods
//---------------------------------------------------------------------------------------------------------------------{

movingAverage(source, length, maType) => 
    switch maType
        "SMA"  => ta.sma (source, length)
        "EMA"  => ta.ema (source, length)
        "HMA"  => ta.hma (source, length)
        "RMA"  => ta.rma (source, length)
        "WMA"  => ta.wma (source, length)
        "VWMA" => ta.vwma(source, length)


isBullishReversal() =>
    (close[2] < open[2]) and
     (low[1] < low[2]) and (high[1] < high[2]) and
     (close > open) and (high > high[2]) //(close > high[1])         and (close[1] < open[1])

isBearishReversal() =>
    (close[2] > open[2]) and
     (high[1] > high[2]) and (low[1] > low[2]) and
     (close < open) and (low < low[2]) //(close < low[1])              and (close[1] > open[1])
     

//---------------------------------------------------------------------------------------------------------------------}
// Calculations - Trend Indicators - Moving Average Cloud
//---------------------------------------------------------------------------------------------------------------------{

maFast = movingAverage(close, maFLength, maType) 
maSlow = movingAverage(close, maSLength, maType) 

// maColor = maFast > maSlow ? #089981 : color.rgb(242, 54, 69)
// ma1NB = plot(trendType == 'Moving Average Cloud' ? maFast : na, "ma fast", color.rgb(8, 153, 129, 81), 1, plot.style_linebr, display = display, editable = false)
// ma2NB = plot(trendType == 'Moving Average Cloud' ? maSlow : na, "ma slow", color.rgb(242, 54, 69, 73), 1, plot.style_linebr, display = display, editable = false)

// fill(ma1NB, ma2NB, math.max(maFast, maSlow), math.min(maFast, maSlow), color.new(maColor, maFast > maSlow ? 99 : 81), color.new(maColor, maFast > maSlow ? 81 : 99))

//---------------------------------------------------------------------------------------------------------------------}
// Calculations - 3-Bar Reversal Pattern
//---------------------------------------------------------------------------------------------------------------------{

C_DownTrend = true
C_UpTrend = true

if trendType == 'Moving Average Cloud'
    if trendFilt == 'Aligned'
	    C_DownTrend := close < maFast and maFast < maSlow
	    C_UpTrend := close > maFast and maFast > maSlow
    else if trendFilt == 'Opposite'
	    C_DownTrend := close > maFast and maFast > maSlow
	    C_UpTrend := close < maFast and maFast < maSlow
    else
        C_DownTrend := true
        C_UpTrend := true

bullishReversal = isBullishReversal() and C_UpTrend
bearishReversal = isBearishReversal() and C_DownTrend

var line lnAT = na
var line lnAB = na
var line lnAT2 = na
var line lnAB2 = na
var label lbAT = na
var box bxA = na
var bool bullProcess = false
var bool bullProcess2 = false
var float bullHigh = na

if bullishReversal and (brpType == 'All' ? true : brpType == 'Enhanced' ? close > high[2] ? true : false : brpType == 'Normal' ? close < high[2] ? true : false : false)
    bullProcess := true

    lbAT := label.new(bar_index, low, '▲', color = color(na), textcolor = color.rgb(41, 98, 255, 07), style = label.style_label_up, size = size.small, tooltip = 'new bullish pattern detected' + (close > high[2] ? ' (enchanced)' : ' (normal)'))

    lnAT := line.new(bar_index[2], high[2], bar_index, high[2], color = color.rgb(41, 98, 255, 53))
    lnAB := line.new(bar_index[1], math.min(low[1], low), bar_index[0], math.min(low[1], low), color = color.rgb(41, 98, 255, 53))
    linefill.new(lnAT, lnAB, color.rgb(41, 98, 255, 73))

    lnAT2 := line.new(bar_index[2], high[2], bar_index, high[2], color = color.rgb(41, 98, 255, 53))
    lnAB2 := line.new(bar_index[1], math.min(low[1], low), bar_index[0], math.min(low[1], low), color = color.rgb(41, 98, 255, 53))

    bullHigh := brpSR == 'Zone' ? math.max(low[1], low) : math.min(low[1], low)

if bullProcess 
    if close[1] > lnAT.get_price(bar_index)
        if bullProcess[1] and bullProcess[1] != bullProcess[2]
            lbAT.set_tooltip('enchanced pattern (confirmed at detection)\nprice activity above the pattern high')
        else
            lbAT.set_tooltip('pattern confirmed ' + str.tostring(bar_index[1] - lbAT.get_x()) + ' bars later')
            label.new(bar_index[1], low[1], '⦁', color = color(na), textcolor = color.rgb(41, 98, 255, 07), style = label.style_label_up, size = size.small, tooltip = 'confirmation bar\nprice activity above the pattern high')
        
        bullProcess := false

        bxA := box.new(bar_index, bullHigh, bar_index, lnAB.get_price(bar_index), color.rgb(41, 98, 255, 73), bgcolor = color.rgb(41, 98, 255, 73))
        bullProcess2 := true

    if close[1] < lnAB.get_price(bar_index) or bearishReversal
        lbAT.set_tooltip('pattern failed\nthe low of the pattern breached')
        bullProcess := false

    if not bullProcess 
        lnAT2.set_x2(bar_index[1])
        lnAB2.set_x2(bar_index[1])
    else
        lnAT2.set_x2(bar_index)
        lnAB2.set_x2(bar_index)

if bullProcess2 and brpSR != 'None'
    if close > bxA.get_bottom()
        bxA.set_right(bar_index)
    else
        bxA.set_right(bar_index)
        bullProcess2 := false


var line lnST = na
var line lnSB = na
var line lnST2 = na
var line lnSB2 = na
var label lbST = na
var box bxS = na
var bool bearProcess = false
var bool bearProcess2 = false
var float bearLow = na

if bearishReversal and (brpType == 'All' ? true : brpType == 'Enhanced' ? close < low[2] ? true : false : brpType == 'Normal' ? close > low[2] ? true : false : false)
    bearProcess := true

    lbST := label.new(bar_index, high, '▼', color = color(na), textcolor = color.rgb(255, 152, 0, 7), style = label.style_label_down, size = size.small, tooltip = 'new bearish pattern detected' + (close < low[2] ? ' (enchanced)' : ' (normal)'))

    lnSB := line.new(bar_index[2], low[2], bar_index, low[2], color = color.rgb(255, 152, 0, 53))
    lnST := line.new(bar_index[1], math.max(high[1], high), bar_index[0], math.max(high[1], high), color = color.rgb(255, 152, 0, 53))
    linefill.new(lnST, lnSB, color.rgb(255, 152, 0, 73))

    lnSB2 := line.new(bar_index[2], low[2], bar_index, low[2], color = color.rgb(255, 152, 0, 53))
    lnST2 := line.new(bar_index[1], math.max(high[1], high), bar_index[0], math.max(high[1], high), color = color.rgb(255, 152, 0, 53))

    bearLow := brpSR == 'Zone' ? math.min(high[1], high) : math.max(high[1], high)

if bearProcess 
    if close[1] > lnST.get_price(bar_index) or bullishReversal
        lbST.set_tooltip('pattern failed\nthe high of the pattern breached')
        bearProcess := false

    if close[1] < lnSB.get_price(bar_index) 
        if bearProcess[1] and bearProcess[1] != bearProcess[2]
            lbST.set_tooltip('enchanced pattern (confirmed at detection)\nprice activity below the pattern low')
        else
            lbST.set_tooltip('pattern confirmed ' + str.tostring(bar_index[1] - lbST.get_x()) + ' bars later')
            label.new(bar_index[1], high[1], '⦁', color = color(na), textcolor = color.rgb(255, 152, 0, 7), style = label.style_label_down, size = size.small, tooltip = 'confirmation bar\nprice activity blow the pattern low')

        bearProcess := false

        bxS := box.new(bar_index, lnST.get_price(bar_index), bar_index, bearLow, color.rgb(255, 152, 0, 73), bgcolor = color.rgb(255, 152, 0, 73))
        bearProcess2 := true

    if not bearProcess 
        lnST2.set_x2(bar_index[1])
        lnSB2.set_x2(bar_index[1])
    else
        lnST2.set_x2(bar_index)
        lnSB2.set_x2(bar_index)

if bearProcess2 and brpSR != 'None'
    if close < bxS.get_top()
        bxS.set_right(bar_index)
    else
        bxS.set_right(bar_index)
        bearProcess2 := false

//---------------------------------------------------------------------------------------------------------------------}
